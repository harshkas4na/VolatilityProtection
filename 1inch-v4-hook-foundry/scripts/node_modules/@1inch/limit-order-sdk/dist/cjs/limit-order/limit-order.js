"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "LimitOrder", {
    enumerable: true,
    get: function() {
        return LimitOrder;
    }
});
var _ethers = require("ethers");
var _byteutils = require("@1inch/byte-utils");
var _assert = /*#__PURE__*/ _interop_require_default(require("assert"));
var _index = require("./eip712/index.js");
var _makertraits = require("./maker-traits.js");
var _extension = require("./extensions/extension.js");
var _sourcetrack = require("./source-track.js");
var _address = require("../address.js");
var _randbigint = require("../utils/rand-bigint.js");
function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _object_spread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property(target, key, source[key]);
        });
    }
    return target;
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _object_spread_props(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
        ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
var LimitOrder = /*#__PURE__*/ function() {
    "use strict";
    function LimitOrder(orderInfo) {
        var makerTraits = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new _makertraits.MakerTraits(0n), extension = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _extension.Extension.default(), config = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
            /**
             * When enabled, orders where maker == receiver will have ZERO_ADDRESS set
             * Used to save calldata costs
             */ optimizeReceiverAddress: true
        };
        _class_call_check(this, LimitOrder);
        _define_property(this, "extension", void 0);
        _define_property(this, "maker", void 0);
        _define_property(this, "receiver", void 0);
        _define_property(this, "makerAsset", void 0);
        _define_property(this, "takerAsset", void 0);
        _define_property(this, "makingAmount", void 0);
        _define_property(this, "takingAmount", void 0);
        _define_property(this, "makerTraits", void 0);
        _define_property(this, "_salt", void 0);
        this.extension = extension;
        (0, _assert.default)(!orderInfo.takerAsset.isNative(), "".concat(orderInfo.takerAsset, " can not be 'takerAsset'. Use wrapper address as 'takerAsset' and 'makerTraits.enableNativeUnwrap' to swap to NATIVE currency"));
        (0, _assert.default)(!orderInfo.makerAsset.isNative(), 'Maker asset can not be NATIVE, use wrapper');
        this.makerAsset = orderInfo.makerAsset;
        this.takerAsset = orderInfo.takerAsset;
        this.makingAmount = orderInfo.makingAmount;
        this.takingAmount = orderInfo.takingAmount;
        this._salt = LimitOrder.verifySalt(orderInfo.salt || LimitOrder.buildSalt(extension), extension);
        this.maker = orderInfo.maker;
        if (config.optimizeReceiverAddress) {
            var _orderInfo_receiver;
            this.receiver = ((_orderInfo_receiver = orderInfo.receiver) === null || _orderInfo_receiver === void 0 ? void 0 : _orderInfo_receiver.equal(orderInfo.maker)) ? _address.Address.ZERO_ADDRESS : orderInfo.receiver || _address.Address.ZERO_ADDRESS;
        } else {
            this.receiver = orderInfo.receiver || orderInfo.maker;
        }
        this.makerTraits = makerTraits;
        (0, _assert.default)(this.makingAmount <= _byteutils.UINT_256_MAX, 'makingAmount too big');
        (0, _assert.default)(this.takingAmount <= _byteutils.UINT_256_MAX, 'takingAmount too big');
        if (!extension.isEmpty()) {
            this.makerTraits.withExtension();
        }
    }
    _create_class(LimitOrder, [
        {
            key: "salt",
            get: function get() {
                return this._salt;
            }
        },
        {
            key: "isNative",
            value: function isNative(chainId, ethOrderFactory, signature) {
                return LimitOrder.isNativeOrder(chainId, ethOrderFactory, this.build(), signature);
            }
        },
        {
            key: "nativeSignature",
            value: /**
     * Returns signature for submitting native order on-chain
     * Only valid if order is native
     *
     * @see FusionOrder.isNative
     * @see FusionOrder.fromNative
     */ function nativeSignature(maker) {
                return new LimitOrder({
                    maker: maker,
                    makerAsset: this.makerAsset,
                    makingAmount: this.makingAmount,
                    takingAmount: this.takingAmount,
                    takerAsset: this.takerAsset,
                    receiver: this.receiver,
                    salt: this.salt
                }, this.makerTraits, undefined, {
                    optimizeReceiverAddress: false
                }).toCalldata();
            }
        },
        {
            key: "setSource",
            value: /**
     * Injects source info to order `salt` [224, 255] bits
     * check `getTrackCodeForSource` implementation for exact injected data
     *
     * @param source order source identifier
     * @see getTrackCodeForSource
     */ function setSource(source) {
                this._salt = (0, _sourcetrack.injectTrackCode)(this.salt, source);
                return this;
            }
        },
        {
            key: "toCalldata",
            value: function toCalldata() {
                return _ethers.AbiCoder.defaultAbiCoder().encode([
                    LimitOrder.Web3Type
                ], [
                    this.build()
                ]);
            }
        },
        {
            key: "build",
            value: function build() {
                var _this_makerTraits;
                return {
                    maker: this.maker.toString(),
                    makerAsset: this.makerAsset.toString(),
                    takerAsset: this.takerAsset.toString(),
                    makerTraits: (((_this_makerTraits = this.makerTraits) === null || _this_makerTraits === void 0 ? void 0 : _this_makerTraits.asBigInt()) || 0n).toString(),
                    salt: this.salt.toString(),
                    makingAmount: this.makingAmount.toString(),
                    takingAmount: this.takingAmount.toString(),
                    receiver: this.receiver.toString()
                };
            }
        },
        {
            key: "getTypedData",
            value: function getTypedData(chainId) {
                var domain = (0, _index.getLimitOrderV4Domain)(chainId);
                return (0, _index.buildOrderTypedData)(domain.chainId, domain.verifyingContract, domain.name, domain.version, this.build());
            }
        },
        {
            key: "getOrderHash",
            value: function getOrderHash(chainId) {
                return (0, _index.getOrderHash)(this.getTypedData(chainId));
            }
        },
        {
            key: "isPrivate",
            value: /**
     * Returns true if only a specific address can fill order
     */ function isPrivate() {
                return this.makerTraits.isPrivate();
            }
        }
    ], [
        {
            key: "buildSalt",
            value: /**
     * Build correct salt for order
     *
     * If order has extension - it is crucial to build correct salt
     * otherwise order won't be ever filled
     *
     * @see https://github.com/1inch/limit-order-protocol/blob/7bc5129ae19832338169ca21e4cf6331e8ff44f6/contracts/OrderLib.sol#L153
     *
     */ function buildSalt(extension) {
                var baseSalt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (0, _randbigint.randBigInt)((1n << 96n) - 1n);
                if (extension.isEmpty()) {
                    return baseSalt;
                }
                return baseSalt << 160n | extension.keccak256() & _byteutils.UINT_160_MAX;
            }
        },
        {
            key: "verifySalt",
            value: function verifySalt(salt, extension) {
                (0, _assert.default)(salt <= _byteutils.UINT_256_MAX, 'salt too big');
                if (extension.isEmpty()) {
                    return salt;
                }
                var hash = salt & _byteutils.UINT_160_MAX;
                var expectedHash = extension.keccak256() & _byteutils.UINT_160_MAX;
                (0, _assert.default)(hash === expectedHash, 'invalid salt: lowest 160 bits should be extension hash');
                return salt;
            }
        },
        {
            key: "fromNative",
            value: function fromNative(chainId, ethOrdersFactory, orderInfo, makerTraits, extension) {
                var _orderInfo = _object_spread_props(_object_spread({}, orderInfo), {
                    makerAsset: LimitOrder.CHAIN_TO_WRAPPER[chainId],
                    receiver: orderInfo.receiver && !orderInfo.receiver.isZero() ? orderInfo.receiver : orderInfo.maker
                });
                // create temp order to calc order hash
                var _order = new LimitOrder(_orderInfo, makerTraits, extension, {
                    optimizeReceiverAddress: false
                });
                var finalOrderInfo = _object_spread_props(_object_spread({}, _orderInfo), {
                    salt: _order.salt,
                    maker: ethOrdersFactory.getProxyAddress(_order.getOrderHash(chainId))
                });
                return new LimitOrder(finalOrderInfo, makerTraits, extension, {
                    optimizeReceiverAddress: false
                });
            }
        },
        {
            key: "isNativeOrder",
            value: function isNativeOrder(chainId, ethOrderFactory, order, signature) {
                try {
                    var orderWithRealMaker = LimitOrder.fromCalldata(signature);
                    var expectedAddress = ethOrderFactory.getProxyAddress(orderWithRealMaker.getOrderHash(chainId));
                    return expectedAddress.equal(new _address.Address(order.maker));
                } catch (e) {
                    return false;
                }
            }
        },
        {
            key: "fromCalldata",
            value: function fromCalldata(bytes) {
                (0, _assert.default)((0, _byteutils.isHexString)(bytes), 'Bytes should be valid hex string with 0x prefix');
                var info = _ethers.AbiCoder.defaultAbiCoder().decode([
                    LimitOrder.Web3Type
                ], bytes);
                var order = info[0];
                return new LimitOrder({
                    salt: order.salt ? BigInt(order.salt) : undefined,
                    maker: new _address.Address(order.maker),
                    receiver: new _address.Address(order.receiver),
                    takingAmount: BigInt(order.takingAmount),
                    makingAmount: BigInt(order.makingAmount),
                    takerAsset: new _address.Address(order.takerAsset),
                    makerAsset: new _address.Address(order.makerAsset)
                }, new _makertraits.MakerTraits(BigInt(order.makerTraits)), undefined, {
                    optimizeReceiverAddress: false
                });
            }
        },
        {
            key: "fromDataAndExtension",
            value: function fromDataAndExtension(data, extension) {
                return new LimitOrder({
                    salt: BigInt(data.salt),
                    maker: new _address.Address(data.maker),
                    receiver: new _address.Address(data.receiver),
                    takingAmount: BigInt(data.takingAmount),
                    makingAmount: BigInt(data.makingAmount),
                    takerAsset: new _address.Address(data.takerAsset),
                    makerAsset: new _address.Address(data.makerAsset)
                }, new _makertraits.MakerTraits(BigInt(data.makerTraits)), extension, {
                    optimizeReceiverAddress: false
                });
            }
        }
    ]);
    return LimitOrder;
}();
var _obj;
_define_property(LimitOrder, "CHAIN_TO_WRAPPER", (_obj = {}, _define_property(_obj, 1, new _address.Address('0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2')), _define_property(_obj, 56, new _address.Address('0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c')), _define_property(_obj, 137, new _address.Address('0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270')), _define_property(_obj, 42161, new _address.Address('0x82af49447d8a07e3bd95bd0d56f35241523fbab1')), _define_property(_obj, 43114, new _address.Address('0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7')), _define_property(_obj, 100, new _address.Address('0xe91d153e0b41518a2ce8dd3d7944fa863463a97d')), _define_property(_obj, 8453, new _address.Address('0x4200000000000000000000000000000000000006')), _define_property(_obj, 10, new _address.Address('0x4200000000000000000000000000000000000006')), _define_property(_obj, 250, new _address.Address('0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83')), _define_property(_obj, 324, new _address.Address('0x5aea5775959fbc2557cc8789bc1bf90a239d9a91')), _define_property(_obj, 59144, new _address.Address('0xe5d7c2a44ffddf6b295a15c148167daaaf5cf34f')), _define_property(_obj, 130, new _address.Address('0x4200000000000000000000000000000000000006')), _define_property(_obj, 146, new _address.Address('0x039e2fb66102314ce7b64ce5ce3e5183bc94ad38')), _obj));
_define_property(LimitOrder, "Web3Type", "tuple(".concat([
    'uint256 salt',
    'address maker',
    'address receiver',
    'address makerAsset',
    'address takerAsset',
    'uint256 makingAmount',
    'uint256 takingAmount',
    'uint256 makerTraits'
], ")"));
