import { EIP712TypedData } from './eip712/index.js';
import { LimitOrderV4Struct, OrderInfoData } from './types.js';
import { MakerTraits } from './maker-traits.js';
import { Extension } from './extensions/extension.js';
import { Address } from '../address.js';
import { ProxyFactory } from '../limit-order-contract/index.js';
export declare class LimitOrder {
    readonly extension: Extension;
    static readonly CHAIN_TO_WRAPPER: Record<number, Address>;
    private static readonly Web3Type;
    readonly maker: Address;
    receiver: Address;
    readonly makerAsset: Address;
    readonly takerAsset: Address;
    readonly makingAmount: bigint;
    readonly takingAmount: bigint;
    readonly makerTraits: MakerTraits;
    private _salt;
    constructor(orderInfo: OrderInfoData, makerTraits?: MakerTraits, extension?: Extension, config?: {
        optimizeReceiverAddress: boolean;
    });
    get salt(): bigint;
    /**
     * Build correct salt for order
     *
     * If order has extension - it is crucial to build correct salt
     * otherwise order won't be ever filled
     *
     * @see https://github.com/1inch/limit-order-protocol/blob/7bc5129ae19832338169ca21e4cf6331e8ff44f6/contracts/OrderLib.sol#L153
     *
     */
    static buildSalt(extension: Extension, baseSalt?: bigint): bigint;
    static verifySalt(salt: bigint, extension: Extension): bigint;
    static fromNative(chainId: number, ethOrdersFactory: ProxyFactory, orderInfo: Omit<OrderInfoData, 'makerAsset'>, makerTraits: MakerTraits, extension: Extension): LimitOrder;
    static isNativeOrder(chainId: number, ethOrderFactory: ProxyFactory, order: LimitOrderV4Struct, signature: string): boolean;
    static fromCalldata(bytes: string): LimitOrder;
    static fromDataAndExtension(data: LimitOrderV4Struct, extension: Extension): LimitOrder;
    isNative(chainId: number, ethOrderFactory: ProxyFactory, signature: string): boolean;
    /**
     * Returns signature for submitting native order on-chain
     * Only valid if order is native
     *
     * @see FusionOrder.isNative
     * @see FusionOrder.fromNative
     */
    nativeSignature(maker: Address): string;
    /**
     * Injects source info to order `salt` [224, 255] bits
     * check `getTrackCodeForSource` implementation for exact injected data
     *
     * @param source order source identifier
     * @see getTrackCodeForSource
     */
    setSource(source: string): this;
    toCalldata(): string;
    build(): LimitOrderV4Struct;
    getTypedData(chainId: number): EIP712TypedData;
    getOrderHash(chainId: number): string;
    /**
     * Returns true if only a specific address can fill order
     */
    isPrivate(): boolean;
}
