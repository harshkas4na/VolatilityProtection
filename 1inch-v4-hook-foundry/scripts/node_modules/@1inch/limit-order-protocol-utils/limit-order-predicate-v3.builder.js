import { LimitOrderProtocolMethodsV3 } from "./model/limit-order-protocol.model";
import { ZX } from "./limit-order-protocol.const";
import { LimitOrderBuilder } from "./limit-order.builder";
import { AbstractSmartcontractFacade } from "./utils/abstract-facade";
export class LimitOrderPredicateV3Builder {
    constructor(facade) {
        this.facade = facade;
        this.and = (...predicates) => {
            const { offsets, data } = LimitOrderBuilder.joinStaticCalls(predicates);
            return this.facade.getContractCallData(LimitOrderProtocolMethodsV3.and, [
                offsets,
                data,
            ]);
        };
        this.or = (...predicates) => {
            const { offsets, data } = LimitOrderBuilder.joinStaticCalls(predicates);
            return this.facade.getContractCallData(LimitOrderProtocolMethodsV3.or, [
                offsets,
                data,
            ]);
        };
        this.eq = (value, callData) => {
            return this.facade.getContractCallData(LimitOrderProtocolMethodsV3.eq, [
                value,
                callData,
            ]);
        };
        this.lt = (value, callData) => {
            return this.facade.getContractCallData(LimitOrderProtocolMethodsV3.lt, [
                value,
                callData,
            ]);
        };
        this.gt = (value, callData) => {
            return this.facade.getContractCallData(LimitOrderProtocolMethodsV3.gt, [
                value,
                callData,
            ]);
        };
        this.nonce = (makerAddress) => {
            return this.facade.getContractCallData(LimitOrderProtocolMethodsV3.nonce, [makerAddress]);
        };
        this.nonceEquals = (makerAddress, makerNonce) => {
            return this.facade.getContractCallData(LimitOrderProtocolMethodsV3.nonceEquals, [makerAddress, makerNonce]);
        };
        /**
         * @param timestamp seconds unit
         */
        this.timestampBelow = (timestamp) => {
            return this.facade.getContractCallData(LimitOrderProtocolMethodsV3.timestampBelow, [ZX + timestamp.toString(16)]);
        };
        /**
         * @param timestamp seconds unit
         */
        this.timestampBelowAndNonceEquals = (timestamp, nonce, address) => {
            const predicateValue = BigInt(address)
                + (BigInt(nonce) << BigInt(160))
                + (BigInt(timestamp) << BigInt(208));
            return this.facade.getContractCallData(LimitOrderProtocolMethodsV3.timestampBelowAndNonceEquals, [ZX + predicateValue.toString(16)]);
        };
        this.arbitraryStaticCall = (target, callData) => {
            const address = target instanceof AbstractSmartcontractFacade
                ? target.contractAddress
                : target;
            if (address.toLowerCase() === this.facade.contractAddress.toLowerCase()) {
                console.warn('Unnecessary arbitraryStaticCall(). '
                    + 'Omit it when interacting with limit-order-protocol methods.');
                return callData;
            }
            return this.facade.getContractCallData(LimitOrderProtocolMethodsV3.arbitraryStaticCall, [
                address,
                callData,
            ]);
        };
    }
}
//# sourceMappingURL=limit-order-predicate-v3.builder.js.map