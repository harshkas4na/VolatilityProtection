import { LimitOrderDecoder } from "../../limit-order.decoder";
import { DecodableCall, PredicateBytes, PredicateFn, } from "../../limit-order-predicate.decoder";
import { unpackTimestampAndNoncePredicate } from "../limit-order.utils";
export class LimitOrderPredicateDecoders {
    constructor() {
        this.or = this.logicalDecoder;
        this.and = this.logicalDecoder;
        this.lt = this.comparingDecoder;
        this.gt = this.comparingDecoder;
        this.eq = this.comparingDecoder;
    }
    arbitraryStaticCall(fn, data, contract) {
        return new PredicateFn(fn.name, {
            target: new PredicateBytes(data.target, contract),
            data: new DecodableCall(data.data, data.target),
        }, contract);
    }
    timestampBelow(fn, data, contract) {
        return new PredicateFn(fn.name, {
            timestamp: new PredicateBytes(data.time, contract),
        }, contract);
    }
    timestampBelowAndNonceEquals(fn, data, contract) {
        const { address, nonce, timestamp, } = unpackTimestampAndNoncePredicate(data.timeNonceAccount.toHexString(), false);
        return new PredicateFn(fn.name, {
            timestamp: new PredicateBytes(timestamp.toString(), contract),
            address: new PredicateBytes(address, contract),
            nonce: new PredicateBytes(nonce.toString(), contract),
        }, contract);
    }
    nonceEquals(fn, data, contract) {
        return new PredicateFn(fn.name, {
            makerAddress: new PredicateBytes(data.makerAddress, contract),
            nonce: new PredicateBytes(data.makerNonce.toHexString(), contract),
        }, contract);
    }
    nonce(fn, data, contract) {
        return new PredicateFn(fn.name, {
            makerAddress: new PredicateBytes(data[0], contract),
        }, contract);
    }
    logicalDecoder(fn, data, contract) {
        const args = LimitOrderDecoder.unpackStaticCalls(data.offsets, data.data);
        return new PredicateFn(fn.name, args.map(calldata => new DecodableCall(calldata, contract)), contract);
    }
    comparingDecoder(fn, data, contract) {
        return new PredicateFn(fn.name, {
            value: new PredicateBytes(data.value.toString(), contract),
            data: new DecodableCall(data.data, contract),
        }, contract);
    }
}
//# sourceMappingURL=limit-order-predicate-decoders.js.map