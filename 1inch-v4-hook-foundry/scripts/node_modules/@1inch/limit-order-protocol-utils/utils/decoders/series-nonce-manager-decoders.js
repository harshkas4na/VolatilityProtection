import { PredicateBytes, PredicateFn, } from "../../limit-order-predicate.decoder";
import { unpackTimestampAndNoncePredicate } from "../limit-order.utils";
export class SeriesNonceManagerDecoders {
    timestampBelowAndNonceEquals(fn, data, contract) {
        const { address, nonce, series, timestamp, } = unpackTimestampAndNoncePredicate(data.timeNonceSeriesAccount.toHexString(), true);
        return new PredicateFn(fn.name, {
            series: new PredicateBytes(series.toString(), contract),
            timestamp: new PredicateBytes(timestamp.toString(), contract),
            address: new PredicateBytes(address, contract),
            nonce: new PredicateBytes(nonce.toString(), contract),
        }, contract);
    }
    nonceEquals(fn, data, contract) {
        return new PredicateFn(fn.name, {
            makerAddress: new PredicateBytes(data.makerAddress, contract),
            nonce: new PredicateBytes(data.makerNonce.toHexString(), contract),
        }, contract);
    }
    nonce(fn, data, contract) {
        return new PredicateFn(fn.name, {
            makerAddress: new PredicateBytes(data[0], contract),
        }, contract);
    }
}
//# sourceMappingURL=series-nonce-manager-decoders.js.map