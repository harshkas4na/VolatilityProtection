import { FunctionFragment, Interface, Result } from '@ethersproject/abi';
import { Address } from "./model/eth.model";
import { AbiItem } from "./model/abi.model";
import { LimitOrderPredicateDecoders } from "./utils/decoders/limit-order-predicate-decoders";
import { BigNumber } from "@ethersproject/bignumber";
import { SeriesNonceManagerDecoders } from "./utils/decoders/series-nonce-manager-decoders";
import { ChainId } from "./limit-order-protocol-addresses.const";
type Bytes = string;
export interface PredicateAstNode {
    type: "function" | "bytes";
    name?: string;
    args?: PredicateAstArguments;
    bytes?: Bytes;
    meta: {
        source: Address | null;
    };
}
export type PredicateAstArguments = Record<string, PredicateAstNode> | Array<PredicateAstNode>;
export declare class DecodableCall {
    readonly calldata: string;
    readonly target: Address;
    constructor(calldata: string, target: Address);
}
export type DecodableArguments = Record<string, DecodableCall | PredicateBytes> | Array<DecodableCall | PredicateBytes>;
interface DecodablePredicateAstNode {
    type: PredicateAstNode["type"];
    name?: PredicateAstNode["name"];
    bytes?: PredicateAstNode["bytes"];
    meta: PredicateAstNode["meta"];
    args?: PredicateAstNode["args"] | DecodableArguments;
}
export declare class PredicateBytes implements DecodablePredicateAstNode {
    readonly bytes: Bytes;
    readonly meta: DecodablePredicateAstNode["meta"];
    readonly type = "bytes";
    constructor(bytes: Bytes, source: DecodablePredicateAstNode["meta"]["source"]);
}
export declare class PredicateFn implements DecodablePredicateAstNode {
    readonly name: NonNullable<DecodablePredicateAstNode["name"]>;
    readonly args: NonNullable<DecodablePredicateAstNode["args"]>;
    readonly meta: DecodablePredicateAstNode["meta"];
    readonly type = "function";
    constructor(name: NonNullable<DecodablePredicateAstNode["name"]>, args: NonNullable<DecodablePredicateAstNode["args"]>, source: DecodablePredicateAstNode["meta"]["source"]);
}
export type ABI = AbiItem[];
/**
 * An ifaceContext.decodeFunctionData result.
 *
 * Object contains arguments by indexed and named keys.
 * Eg:
 *
 * ```
 * solMethod(255, '0xff') // solMethod(uint8 count, bytes data)
 * // ->
 * {
 *     0: 255,
 *     1: '0xff',
 *     count: 255,
 *     data: '0xff',
 * }
 * ```
 */
export type CallArguments = Result | {
    [key: string]: string | BigNumber;
};
/**
 * See [CallArguments] for details.
 *
 * @param interfaces access it in case if you want implement arbitraryStaticCall-like method
 */
type Decoder = (fn: FunctionFragment, data: Required<CallArguments>, address: Address) => DecodablePredicateAstNode;
/**
 * {
 *     methodName: data => PredicateAstNode,
 * //  or
 *     methodSignature0x: data => PredicateAstNode,
 * }
 */
export type DecodersImplementation<Implementation> = {
    [K in keyof Implementation]: (Implementation[K] extends Function ? Decoder : Implementation[K]);
};
type DecodableInterfaces<T> = Record<Address, {
    iface: Interface;
    decoders: DecodersImplementation<T>;
}>;
type DecodableContracts<T> = Record<Address, {
    abi: ABI;
    decoders: DecodersImplementation<T>;
}>;
export type PredicateAstMatcher = (node: PredicateAstNode) => boolean;
export declare class LimitOrderPredicateDecoder<T extends ChainId, Decoders extends DecodersImplementation<Decoders>> {
    private readonly contractAddress;
    private readonly chainId;
    decodableInterfaces: DecodableInterfaces<Decoders> | DecodableInterfaces<LimitOrderPredicateDecoders> | DecodableInterfaces<SeriesNonceManagerDecoders>;
    defaultAddress: string;
    private readonly limitOrderABI;
    private readonly seriesNonceManagerABI;
    constructor(contractAddress: Address, chainId: T, limitOrderABI: AbiItem[], seriesNonceManagerABI: AbiItem[], decodableContracts?: DecodableContracts<Decoders>);
    decode(calldata: string): PredicateAstNode;
    findFirstDFS: (tree: PredicateAstNode, matcher: PredicateAstMatcher) => PredicateAstNode | null;
    private decodableContractsToDecodableInterfaces;
    private parseCalldata;
    private parseDecodableCall;
    private mapArgs;
}
export {};
