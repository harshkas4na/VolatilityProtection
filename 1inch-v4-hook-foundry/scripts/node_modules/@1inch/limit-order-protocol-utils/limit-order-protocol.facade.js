import { __awaiter } from "tslib";
import { EIP712_DOMAIN, LIMIT_ORDER_PROTOCOL_ABI, PROTOCOL_NAME, PROTOCOL_VERSION, TypedDataVersion, } from './limit-order-protocol.const';
import { LimitOrderProtocolMethods, } from './model/limit-order-protocol.model';
import { compactSignature, } from './utils/limit-order.utils';
import { TypedDataUtils } from '@metamask/eth-sig-util';
import { AbstractSmartcontractFacade } from './utils/abstract-facade';
import { solidityPacked } from "ethers";
export class LimitOrderProtocolFacade extends AbstractSmartcontractFacade {
    constructor() {
        super(...arguments);
        this.ABI = LIMIT_ORDER_PROTOCOL_ABI;
    }
    fillLimitOrder(params) {
        const { order, signature, amount, takerTraits } = params;
        const { r, vs } = compactSignature(signature);
        return this.getContractCallData(LimitOrderProtocolMethods.fillOrder, [
            order,
            r,
            vs,
            amount,
            takerTraits,
        ]);
    }
    fillLimitOrderArgs(params) {
        const { order, signature, amount, takerTraits, args, } = params;
        const { r, vs } = compactSignature(signature);
        return this.getContractCallData(LimitOrderProtocolMethods.fillOrderArgs, [
            order,
            r,
            vs,
            amount,
            takerTraits,
            args,
        ]);
    }
    permitAndCall(params) {
        const { permit, permitToken, } = params;
        const packedPermit = solidityPacked(['address', 'bytes'], [permitToken, permit]);
        const fillOrderArgsCalldata = this.fillLimitOrderArgs(params);
        return this.getContractCallData(LimitOrderProtocolMethods.permitAndCall, [packedPermit, fillOrderArgsCalldata]);
    }
    cancelLimitOrder(makerTraits, orderHash) {
        return this.getContractCallData(LimitOrderProtocolMethods.cancelOrder, [
            makerTraits,
            orderHash,
        ]);
    }
    increaseEpoch(series) {
        return this.getContractCallData(LimitOrderProtocolMethods.increaseEpoch, [
            series
        ]);
    }
    epoch(maker, series) {
        const calldata = this.getContractCallData(LimitOrderProtocolMethods.epoch, [
            maker,
            series,
        ]);
        return this.makeViewCall(calldata, BigInt);
    }
    checkPredicate(predicate) {
        return __awaiter(this, void 0, void 0, function* () {
            const callData = this.getContractCallData(LimitOrderProtocolMethods.checkPredicate, [predicate]);
            const result = yield this.makeViewCall(callData, BigInt);
            try {
                return result === BigInt(1);
            }
            catch (e) {
                console.error(e);
                return false;
            }
        });
    }
    remainingInvalidatorForOrder(maker, orderHash) {
        const calldata = this.getContractCallData(LimitOrderProtocolMethods.remainingInvalidatorForOrder, [
            maker,
            orderHash,
        ]);
        return this.makeViewCall(calldata, BigInt);
    }
    rawRemainingInvalidatorForOrder(maker, orderHash) {
        const calldata = this.getContractCallData(LimitOrderProtocolMethods.rawRemainingInvalidatorForOrder, [
            maker,
            orderHash,
        ]);
        return this.makeViewCall(calldata, BigInt);
    }
    // https://github.com/1inch/limit-order-protocol/blob/v3-prerelease/test/helpers/eip712.js#L22
    domainSeparator() {
        const hex = '0x' + TypedDataUtils.hashStruct('EIP712Domain', {
            name: PROTOCOL_NAME,
            version: PROTOCOL_VERSION,
            chainId: this.chainId,
            verifyingContract: this.contractAddress,
        }, { EIP712Domain: EIP712_DOMAIN }, TypedDataVersion).toString('hex');
        return Promise.resolve(hex);
    }
    orderHash(order) {
        const calldata = this.getContractCallData(LimitOrderProtocolMethods.hashOrder, [
            order
        ]);
        return this.makeViewCall(calldata);
    }
    makeViewCall(calldata, parser) {
        return this.providerConnector
            .ethCall(this.contractAddress, calldata)
            .then(parser ? parser : undefined);
    }
}
//# sourceMappingURL=limit-order-protocol.facade.js.map