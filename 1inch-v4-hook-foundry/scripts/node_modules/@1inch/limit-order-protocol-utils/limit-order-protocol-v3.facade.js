import { __awaiter } from "tslib";
import { AbstractSmartcontractFacade } from "./utils/abstract-facade";
import { LimitOrderProtocolMethodsV3 } from "./model/limit-order-protocol.model";
import { LIMIT_ORDER_PROTOCOL_V3_ABI } from "./limit-order-protocol.const";
import { BigNumber } from "@ethersproject/bignumber";
export class LimitOrderProtocolV3Facade extends AbstractSmartcontractFacade {
    constructor() {
        super(...arguments);
        this.ABI = LIMIT_ORDER_PROTOCOL_V3_ABI;
    }
    checkPredicate(order) {
        const callData = this.getContractCallData(LimitOrderProtocolMethodsV3.checkPredicate, [order]);
        return this.providerConnector
            .ethCall(this.contractAddress, callData)
            .catch((error) => {
            console.error(error);
            return false;
        })
            .then((result) => {
            try {
                return BigNumber.from(result).toNumber() === 1;
            }
            catch (e) {
                console.error(e);
                return false;
            }
        });
    }
    cancelLimitOrder(order) {
        return this.getContractCallData(LimitOrderProtocolMethodsV3.cancelOrder, [
            order,
        ]);
    }
    nonce(makerAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const callData = this.getContractCallData(LimitOrderProtocolMethodsV3.nonce, [makerAddress]);
            const nonce = yield this.providerConnector
                .ethCall(this.contractAddress, callData);
            return BigInt(nonce);
        });
    }
    advanceNonce(count) {
        return this.getContractCallData(LimitOrderProtocolMethodsV3.advanceNonce, [count]);
    }
    increaseNonce() {
        return this.getContractCallData(LimitOrderProtocolMethodsV3.increaseNonce);
    }
    remaining(orderHash) {
        const callData = this.getContractCallData(LimitOrderProtocolMethodsV3.remaining, [orderHash]);
        return this.providerConnector
            .ethCall(this.contractAddress, callData)
            .then((result) => {
            const response = this.parseRemainingResponse(result);
            if (response !== null) {
                return response;
            }
            return Promise.reject(result);
        });
    }
    parseRemainingResponse(response) {
        if (response.length === 66) {
            return BigNumber.from(response);
        }
        return null;
    }
    hashOrder(order) {
        return this.getContractCallData(LimitOrderProtocolMethodsV3.hashOrder, [
            order,
        ]);
    }
    callHashOrder(order) {
        return this.providerConnector
            .ethCall(this.contractAddress, this.hashOrder(order));
    }
    isValidSignature(orderHash, signature) {
        return this.getContractCallData(LimitOrderProtocolMethodsV3.isValidSignature, [
            orderHash,
            signature
        ]);
    }
    callIsValidSignature(orderHash, signature) {
        return this.providerConnector
            .ethCall(this.contractAddress, this.isValidSignature(orderHash, signature));
    }
}
//# sourceMappingURL=limit-order-protocol-v3.facade.js.map