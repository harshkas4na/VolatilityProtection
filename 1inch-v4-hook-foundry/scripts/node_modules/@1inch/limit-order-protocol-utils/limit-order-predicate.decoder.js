import { ZX } from "./limit-order-protocol.const";
import { seriesNonceManagerContractAddresses } from "./series-nonce-manager.const";
import { Interface } from '@ethersproject/abi';
import { isIterable, mapObject } from "./utils/helpers";
import { LimitOrderPredicateDecoders } from "./utils/decoders/limit-order-predicate-decoders";
import { SeriesNonceManagerDecoders } from "./utils/decoders/series-nonce-manager-decoders";
import { trim0x } from "./utils/limit-order.utils";
export class DecodableCall {
    constructor(calldata, target) {
        this.calldata = calldata;
        this.target = target;
    }
}
export class PredicateBytes {
    constructor(bytes, source) {
        this.bytes = bytes;
        this.type = "bytes";
        this.meta = {
            source,
        };
    }
}
export class PredicateFn {
    constructor(name, args, source) {
        this.name = name;
        this.args = args;
        this.type = "function";
        this.meta = {
            source,
        };
    }
}
export class LimitOrderPredicateDecoder {
    constructor(contractAddress, chainId, limitOrderABI, seriesNonceManagerABI, decodableContracts = {}) {
        this.contractAddress = contractAddress;
        this.chainId = chainId;
        this.findFirstDFS = (tree, matcher) => {
            if (matcher(tree))
                return tree;
            if (tree.args) {
                const args = isIterable(tree.args)
                    ? Array.from(tree.args)
                    : Object.values(tree.args);
                for (const arg of args) {
                    const result = this.findFirstDFS(arg, matcher);
                    if (result)
                        return result;
                }
            }
            return null;
        };
        // eslint-disable-next-line
        this.parseCalldata = (calldata, address) => {
            const selector = calldata.substring(0, 10);
            const decodableIface = this.decodableInterfaces[address];
            if (!decodableIface)
                return new PredicateBytes(calldata, address);
            let fn;
            try {
                fn = decodableIface.iface.getFunction(selector);
            }
            catch (e) {
                // eslint-disable-next-line max-len
                console.warn(`Tried to decode unknown function with signature ${selector} on ${address}.`);
                return new PredicateBytes(calldata, address);
            }
            const data = decodableIface.iface.decodeFunctionData(fn, calldata);
            const decoder = (decodableIface.decoders[fn.name]
                || decodableIface.decoders[selector]
                || decodableIface.decoders[selector.substring(2)]);
            if (!decoder)
                return new PredicateBytes(calldata, address);
            const decoded = decoder(fn, data, address);
            const result = Object.assign({}, decoded);
            const { args } = decoded;
            if (args) {
                if (isIterable(args)) {
                    result.args = Array.from(args).map(this.mapArgs);
                }
                else {
                    result.args = mapObject(args, this.mapArgs);
                }
            }
            return result;
        };
        this.parseDecodableCall = (call) => {
            return this.parseCalldata(ZX + trim0x(call.calldata), call.target.toLowerCase());
        };
        this.mapArgs = (arg) => {
            if (arg instanceof DecodableCall) {
                return this.parseDecodableCall(arg);
            }
            return arg;
        };
        this.limitOrderABI = limitOrderABI;
        this.seriesNonceManagerABI = seriesNonceManagerABI;
        this.defaultAddress = this.contractAddress;
        this.decodableInterfaces = {
            [this.defaultAddress]: {
                iface: new Interface(this.limitOrderABI),
                decoders: new LimitOrderPredicateDecoders(),
            },
            [seriesNonceManagerContractAddresses[this.chainId].toLowerCase()]: {
                iface: new Interface(this.seriesNonceManagerABI),
                decoders: new SeriesNonceManagerDecoders(),
            },
        };
        // User defined decoders
        Object.assign(this.decodableInterfaces, this.decodableContractsToDecodableInterfaces(decodableContracts));
    }
    decode(calldata) {
        return this.parseCalldata(calldata, this.defaultAddress);
    }
    decodableContractsToDecodableInterfaces(decodableContracts) {
        return Object.assign({}, ...Object.entries(decodableContracts).map(([address, { abi, decoders }]) => {
            return [
                address.toLowerCase(),
                {
                    iface: new Interface(abi),
                    decoders,
                }
            ];
        }));
    }
}
//# sourceMappingURL=limit-order-predicate.decoder.js.map