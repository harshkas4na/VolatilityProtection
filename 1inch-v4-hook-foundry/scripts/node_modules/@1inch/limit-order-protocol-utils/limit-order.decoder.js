import { InteractionsFieldsV3, InteractionsFields, } from "./model/limit-order-protocol.model";
import { parseInteractionForField, trim0x, UINT32_BITMASK, UINT32_BITS, getN, } from "./utils/limit-order.utils";
import { ZX } from "./limit-order-protocol.const";
import { _ALLOW_MULTIPLE_FILLS_FLAG, _HAS_EXTENSION_FLAG, _NEED_EPOCH_CHECK_FLAG, _NO_PARTIAL_FILLS_FLAG, _NO_PRICE_IMPROVEMENT_FLAG, _UNWRAP_WETH_FLAG, _USE_PERMIT2_FLAG, ALLOWED_SENDER_MASK, EXPIRY_MASK, EXPIRY_SHIFT, NONCE_MASK, NONCE_SHIFT, SERIES_MASK, SERIES_SHIFT } from "./utils/maker-traits.const";
import Web3 from "web3";
export class LimitOrderDecoder {
    static unpackExtension(extension) {
        extension = trim0x(extension);
        const offsetsInHex = ZX + extension.slice(0, 64);
        const offsets = BigInt(offsetsInHex);
        const interactions = LimitOrderDecoder.unpackInteractions(offsets, extension.slice(64, extension.length));
        const extensionBigInt = BigInt(ZX + extension);
        const offset = (extensionBigInt >> BigInt(224)) + BigInt(0x20);
        const customData = ZX + extension.slice(Number(offset), extension.length);
        return {
            interactions: interactions !== null && interactions !== void 0 ? interactions : ZX,
            customData: customData !== null && customData !== void 0 ? customData : ZX,
        };
    }
    static unpackMakerTraits(makerTraits) {
        const makerTraitsAsBigInt = BigInt(makerTraits);
        const series = (makerTraitsAsBigInt >> BigInt(SERIES_SHIFT)) & SERIES_MASK;
        const nonce = (makerTraitsAsBigInt >> BigInt(NONCE_SHIFT)) & NONCE_MASK;
        const expiry = (makerTraitsAsBigInt >> BigInt(EXPIRY_SHIFT)) & EXPIRY_MASK;
        const allowedSender = makerTraitsAsBigInt & ALLOWED_SENDER_MASK;
        const unwrapWeth = !!getN(makerTraitsAsBigInt, _UNWRAP_WETH_FLAG);
        const allowMultipleFills = !!getN(makerTraitsAsBigInt, _ALLOW_MULTIPLE_FILLS_FLAG);
        const allowPartialFill = !getN(makerTraitsAsBigInt, _NO_PARTIAL_FILLS_FLAG);
        const allowPriceImprovement = !getN(makerTraitsAsBigInt, _NO_PRICE_IMPROVEMENT_FLAG);
        const shouldCheckEpoch = !!getN(makerTraitsAsBigInt, _NEED_EPOCH_CHECK_FLAG);
        const usePermit2 = !!getN(makerTraitsAsBigInt, _USE_PERMIT2_FLAG);
        const hasExtension = !!getN(makerTraitsAsBigInt, _HAS_EXTENSION_FLAG);
        return {
            series,
            nonce,
            expiry: Number(expiry),
            allowedSender: allowedSender.toString(16).padEnd(20, '0'),
            unwrapWeth,
            allowMultipleFills,
            allowPartialFill,
            allowPriceImprovement,
            shouldCheckEpoch,
            usePermit2,
            hasExtension,
        };
    }
    static unpackInteractionsV3(offsets, interactions) {
        return LimitOrderDecoder.unpackAllInteractions(offsets, interactions, InteractionsFieldsV3);
    }
    static unpackInteractions(offsets, interactions) {
        return LimitOrderDecoder.unpackAllInteractions(offsets, interactions, InteractionsFields);
    }
    static unpackInteraction(order, name) {
        return parseInteractionForField(BigInt(order.offsets), order.interactions, InteractionsFieldsV3[name]);
    }
    static isSaltCorrect(salt, extension) {
        const extensionHash = BigInt(Web3.utils.keccak256(extension))
            & ((BigInt(1) << BigInt(160)) - BigInt(1));
        return BigInt(salt) === extensionHash;
    }
    static unpackStaticCalls(offsets, interactions) {
        const offsetsBI = BigInt(offsets);
        const data = trim0x(interactions);
        const result = [];
        let previous = BigInt(0);
        let current = BigInt(0);
        // See PredicateHelper.and in limit-order-protocol
        for (let i = BigInt(0); (current = (offsetsBI >> i) & UINT32_BITMASK); i += UINT32_BITS) {
            const calldata = data.slice(Number(previous) * 2, Number(current) * 2);
            result.push(calldata);
            previous = current;
        }
        return result;
    }
    static unpackAllInteractions(offsets, interactions, interactionsFields) {
        const offsetsBN = BigInt(offsets);
        const parsedInteractions = {};
        Object.entries(interactionsFields).forEach(([name, position]) => {
            parsedInteractions[name] = parseInteractionForField(offsetsBN, interactions, position);
        });
        return parsedInteractions;
    }
}
//# sourceMappingURL=limit-order.decoder.js.map